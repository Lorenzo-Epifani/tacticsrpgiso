[gd_scene load_steps=6 format=3 uid="uid://v4p8oi08j7at"]

[ext_resource type="Script" path="res://scenes/game.gd" id="1_52ifh"]
[ext_resource type="PackedScene" uid="uid://cy2vocthpn1gi" path="res://scenes/meta_system.tscn" id="2_d8jtd"]
[ext_resource type="PackedScene" uid="uid://dvdpiyjd8o0rd" path="res://scenes/game_manager.tscn" id="3_q2e5h"]

[sub_resource type="GDScript" id="GDScript_4b2bb"]
script/source = "extends Node
class_name Meta

var races_path = \"res://races/\"  # Percorso base delle razze
var class_data = {}  # Dizionario con dati delle classi per razza
var race_class_dict = {}  # Dizionario a doppia chiave simmetrica

# ðŸ”¹ Carica il dizionario alla creazione del nodo (PRIMA di _ready)
func _init():
	load_race_classes()

# ðŸ”¹ Scansiona la cartella delle razze e costruisce il dizionario
func load_race_classes():
	var dir = DirAccess.open(races_path)
	if not dir:
		print(\"Errore: Cartella races non trovata!\")
		return
	
	dir.list_dir_begin()
	var race = dir.get_next()
	
	while race != \"\":
		if dir.current_is_dir():  # Se Ã¨ una cartella (razza)
			scan_race_classes(race)  # Scansiona classi dentro la razza
		race = dir.get_next()

# ðŸ”¹ Scansiona le classi dentro ogni razza e costruisce il dizionario
func scan_race_classes(race):
	var race_dir = DirAccess.open(races_path + race + \"/\")
	if not race_dir:
		return
	
	race_dir.list_dir_begin()
	var class_folder = race_dir.get_next()
	
	while class_folder != \"\":
		if race_dir.current_is_dir():  # Se Ã¨ una cartella (classe)
			if class_folder in class_data:
				class_data[class_folder].append(race)  # Se la classe esiste giÃ , aggiungi la razza
			else:
				class_data[class_folder] = [race]  # Nuova classe
			
			# ðŸ”¹ Costruisci il dizionario a doppia chiave simmetrica
			for other_race in class_data[class_folder]:
				var key = get_symmetric_key(race, other_race)
				race_class_dict[key] = load_class_data(race, class_folder)

		class_folder = race_dir.get_next()

# ðŸ”¹ Rende la chiave del dizionario simmetrica
func get_symmetric_key(a, b):
	return [min(a, b), max(a, b)]  # Ordina sempre la chiave

# ðŸ”¹ Carica i dati della classe specifica

	#var class_path = races_path + race + \"/\" + class_name + \"/data.json\"
	#if FileAccess.file_exists(class_path):
	#	var file = FileAccess.open(class_path, FileAccess.READ)
#		return JSON.parse_string(file.get_as_text())  # Converte JSON in Dictionary
	#return {}
"

[sub_resource type="GDScript" id="GDScript_ari6u"]
script/source = "extends Node

class_name GM
var battle_scene = load(\"res://scenes/battle/base_fight.tscn\")  # Carica la scena
#var other_scene = load(\"res://NewScene.tscn\")  # Carica la scena

var event_queue=[
{
	\"type\":\"battle\",
	\"units\":{
		\"enemies\":[
		{\"type\":\"human_warrior\" ,\"coord\": Vector2i(0, 0)},
		{\"type\":\"fire_human_warrior\" ,\"coord\": Vector2i(2, 2)}
		],
		\"allies\":[],
		\"neutral\":[],
	}
}
]


# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	go_next()

func go_next():
	var event_data = event_queue.pop_front()
	var parent = get_parent()
	match event_data['type']:
		\"battle\":
			var game = get_parent()  # Trova il nodo genitore
			var battle = battle_scene.instantiate()  # Crea l'istanza
			await get_tree().process_frame
			battle.battle_data = event_data
			parent.add_child(battle)  # Aggiunge il nodo come fratello		\"cutscene\":
			print(\"cutscene_todo\")
		\"sequence\":
			print(\"sequence_todo\")
		\"worldmap\":
			print(\"sequence_todo\")

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	pass
"

[node name="Game" type="Node2D"]
script = ExtResource("1_52ifh")

[node name="MetaSystem" parent="." instance=ExtResource("2_d8jtd")]
script = SubResource("GDScript_4b2bb")

[node name="GameManager" parent="." instance=ExtResource("3_q2e5h")]
script = SubResource("GDScript_ari6u")
